using UIForia.Util;

namespace UIForia.Style {

    // Note: Most of this class gets generated by the style generator

    public static partial class PropertyParsers {

        internal static readonly PropertyParseEntry[] s_parseEntries;
        internal static readonly ShorthandEntry[] s_ShorthandEntries;
        internal static readonly IStylePropertyParser[] s_ParserTable;
        internal static readonly IStyleShorthandParser[] s_ShorthandParserTable;
        internal static readonly string[] s_PropertyNames;
        internal static readonly string[] s_ShorthandNames;

        public static int PropertyCount => s_PropertyNames.Length;

        public static unsafe bool TryResolvePropertyId(char* idName, int start, int length, out PropertyParseEntry entry) {
            int num1 = 0;
            int num2 = s_parseEntries.Length - 1;

            while (num1 <= num2) {
                int index1 = num1 + (num2 - num1 >> 1);

                int compare = StringUtil.CharCompareOrdinal(s_parseEntries[index1].loweredName, idName, start, length);

                if (compare == 0) {
                    entry = s_parseEntries[index1];
                    return true;
                }

                if (compare < 0) {
                    num1 = index1 + 1;
                }
                else {
                    num2 = index1 - 1;
                }
            }

            entry = default;
            return false;
        }

        public static unsafe bool TryResolvePropertyId(char[] idName, int start, int length, out PropertyParseEntry entry) {
            fixed (char* charptr = idName) {
                return TryResolvePropertyId(charptr, start, length, out entry);
            }
        }

        public static unsafe bool TryResolvePropertyId(string idName, out PropertyParseEntry entry) {
            fixed (char* charptr = idName) {
                return TryResolvePropertyId(charptr, 0, idName.Length, out entry);
            }
        }

        public static unsafe bool TryResolvePropertyId(CharSpan loweredSpan, out PropertyParseEntry entry) {
            return TryResolvePropertyId(loweredSpan.data, 0, loweredSpan.Length, out entry);
        }

        public static unsafe bool TryResolveShorthand(CharSpan loweredSpan, out ShorthandEntry entry) {
            int num1 = 0;
            int num2 = s_ShorthandEntries.Length - 1;

            while (num1 <= num2) {
                int index1 = num1 + (num2 - num1 >> 1);

                int compare = StringUtil.CharCompareOrdinal(s_ShorthandEntries[index1].loweredName, loweredSpan.data, loweredSpan.rangeStart, loweredSpan.Length);

                if (compare == 0) {
                    entry = s_ShorthandEntries[index1];
                    return true;
                }

                if (compare < 0) {
                    num1 = index1 + 1;
                }
                else {
                    num2 = index1 - 1;
                }
            }

            entry = default;
            return false;
        }

    }

    public struct ShorthandEntry {

        public readonly string name;
        public readonly string loweredName;
        public IStyleShorthandParser parser;
        public int index;

        public ShorthandEntry(string name, int index, IStyleShorthandParser parser) {
            this.name = name;
            this.loweredName = name.ToLower();
            this.parser = parser;
            this.index = index;
        }

    }

    public struct PropertyParseEntry {

        public readonly string name;
        public readonly string loweredName;
        public readonly PropertyId propertyId;
        public readonly IStylePropertyParser parser;

        public PropertyParseEntry(string name, PropertyId propertyId, IStylePropertyParser parser) {
            this.name = name;
            this.propertyId = propertyId;
            this.parser = parser;
            this.loweredName = name.ToLower();
        }

    }

}